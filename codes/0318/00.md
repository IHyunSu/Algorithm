# ⚔️ Divide and Conquer (분할 정복)

**Divide and Conquer**는 큰 문제를 더 작고 유사한 하위 문제로 나누어 해결한 후, 그 결과를 결합하여 전체 문제를 해결하는 전략입니다. 이 전략은 다음과 같은 세 단계로 이루어집니다:

1. **Divide (분할)**: 문제를 더 작은 하위 문제로 나눈다.
2. **Conquer (정복)**: 하위 문제를 재귀적으로 해결한다.
3. **Combine (결합)**: 하위 문제의 해답을 결합하여 전체 문제의 해답을 구한다.

---

## 📌 대표적인 예시

### 1. 🧭 이진 탐색 (Binary Search)

정렬된 배열에서 특정 값을 찾기 위해, 배열을 반으로 나누어 탐색 범위를 줄이는 방법.

- **분할**: 배열을 반으로 나눔
- **정복**: 가운데 값을 기준으로 좌/우 중 한쪽에서 탐색
- **결합**: 조건에 따라 위치 반환

> ⏱ 시간 복잡도: **O(log n)**

---

### 2. 🧩 병합 정렬 (Merge Sort)

배열을 계속 반으로 나누고, 나눈 배열들을 정렬하여 병합.

- **분할**: 배열을 반으로 나눔
- **정복**: 각 하위 배열을 재귀적으로 정렬
- **결합**: 두 정렬된 배열을 병합

> ⏱ 시간 복잡도: **O(n log n)**

---

### 3. ⚡ 빠른 정렬 (Quick Sort)

기준(pivot) 값을 정해, 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하여 정렬.

- **분할**: pivot 기준으로 분할
- **정복**: 각 부분을 재귀적으로 정렬
- **결합**: 이미 제자리에 있으므로 별도 결합 없음

> ⏱ 시간 복잡도: 평균 **O(n log n)** / 최악 **O(n²)**

---

### 4. 🔢 행렬 제곱 (Matrix Exponentiation)

행렬의 거듭제곱을 효율적으로 계산하기 위해, 제곱을 분할하여 계산.

- **분할**: n승을 절반씩 줄여나감
- **정복**: 재귀적으로 제곱을 계산
- **결합**: 중간 결과들을 곱함

> ⏱ 시간 복잡도: **O(log n)**

---

### 5. 🧱 트루미노 퍼즐 (Tromino Tiling)

2^n × 2^n 보드에서 한 칸이 비었을 때, 나머지를 L자 모양 타일로 채우는 퍼즐 문제.

- **분할**: 보드를 네 부분으로 나눔
- **정복**: 각 보드를 재귀적으로 타일링
- **결합**: 중앙에 트루미노 타일을 추가

> ⏱ 시간 복잡도: **O(n²)** 또는 **O(4^k)**

---

## ✅ 요약

| 알고리즘          | 핵심 전략                 | 시간 복잡도       |
|-------------------|----------------------------|-------------------|
| 이진 탐색         | 배열 절반으로 분할         | O(log n)          |
| 병합 정렬         | 정렬 후 병합               | O(n log n)        |
| 빠른 정렬         | pivot 기준으로 분할        | O(n log n) / O(n²)|
| 행렬 제곱         | 거듭제곱을 분할 계산        | O(log n)          |
| 트루미노 퍼즐     | 보드 분할 후 중앙 채우기    | O(n²) 또는 O(4^k) |

Divide and Conquer는 재귀를 잘 활용하며, 효율적인 알고리즘의 핵심 전략으로 자주 사용됩니다.
