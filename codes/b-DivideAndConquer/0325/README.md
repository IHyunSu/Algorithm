# âš”ï¸ Divide and Conquer (ë¶„í•  ì •ë³µ)

**Divide and Conquer**ëŠ” í° ë¬¸ì œë¥¼ ë” ì‘ê³  ìœ ì‚¬í•œ í•˜ìœ„ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í•´ê²°í•œ í›„, ê·¸ ê²°ê³¼ë¥¼ ê²°í•©í•˜ì—¬ ì „ì²´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì „ëµì…ë‹ˆë‹¤. ì´ ì „ëµì€ ë‹¤ìŒê³¼ ê°™ì€ ì„¸ ë‹¨ê³„ë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤:

1. **Divide (ë¶„í• )**: ë¬¸ì œë¥¼ ë” ì‘ì€ í•˜ìœ„ ë¬¸ì œë¡œ ë‚˜ëˆˆë‹¤.
2. **Conquer (ì •ë³µ)**: í•˜ìœ„ ë¬¸ì œë¥¼ ì¬ê·€ì ìœ¼ë¡œ í•´ê²°í•œë‹¤.
3. **Combine (ê²°í•©)**: í•˜ìœ„ ë¬¸ì œì˜ í•´ë‹µì„ ê²°í•©í•˜ì—¬ ì „ì²´ ë¬¸ì œì˜ í•´ë‹µì„ êµ¬í•œë‹¤.

---

## ğŸ“Œ ëŒ€í‘œì ì¸ ì˜ˆì‹œ

### 1. ğŸ”¢ ìŠ¤íŠ¸ë¼ì„¼ í–‰ë ¬ ê³±ì…ˆ (Strassen's Matrix Multiplication)

í–‰ë ¬ ê³±ì…ˆì—ì„œ ê³±ì…ˆ íšŸìˆ˜ë¥¼ ì¤„ì—¬ ë” ë¹ ë¥´ê²Œ ê³„ì‚°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.

- **ë¶„í• **: ë‘ í–‰ë ¬ì„ ê°ê° 4ê°œì˜ í•˜ìœ„ í–‰ë ¬ë¡œ ë‚˜ëˆ”
- **ì •ë³µ**: 7ê°œì˜ ê³±ì…ˆì„ ì¬ê·€ì ìœ¼ë¡œ ê³„ì‚°
- **ê²°í•©**: ê²°ê³¼ë¥¼ í•©ì³ ì „ì²´ í–‰ë ¬ì„ êµ¬ì„±

> â± ì‹œê°„ ë³µì¡ë„: **O(n^2.81)**

---

### 2. ğŸ§® ì¹´ë¼ì¸ ë°” ì •ìˆ˜ ê³±ì…ˆ (Karatsuba's Integer Multiplication)

í° ìˆ˜ì˜ ê³±ì…ˆì„ 3ê°œì˜ ê³±ì…ˆìœ¼ë¡œ ì¤„ì—¬ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•.

- **ë¶„í• **: ìˆ«ìë¥¼ ì ˆë°˜ìœ¼ë¡œ ë‚˜ëˆ”
- **ì •ë³µ**: 3ê°œì˜ ê³±ì…ˆì„ ìˆ˜í–‰
- **ê²°í•©**: ê³±ì…ˆ ê²°ê³¼ë¥¼ ë”í•˜ê³  ë¹¼ì„œ ìµœì¢… ê³„ì‚°

> â± ì‹œê°„ ë³µì¡ë„: **O(n^1.585)**

---

### 3. ğŸŒ€ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ ê³„ì‚° (Fibonacci by Divide and Conquer)

í–‰ë ¬ ì œê³± ë˜ëŠ” ê³µì‹ ì´ìš©í•˜ì—¬ ë¹ ë¥´ê²Œ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ ê³„ì‚°.

- **ë¶„í• **: F(n)ì„ F(k), F(k+1)ë¡œ ë‚˜ëˆ”
- **ì •ë³µ**: ì¬ê·€ì ìœ¼ë¡œ F(k), F(k+1) ê³„ì‚°
- **ê²°í•©**: ê³µì‹ìœ¼ë¡œ F(n) ê³„ì‚°

> â± ì‹œê°„ ë³µì¡ë„: **O(log n)**

---

### 4. ğŸ–¼ï¸ ì¿¼ë“œíŠ¸ë¦¬ ì¸ì½”ë” (Quadtree Encoder)

ì´ë¯¸ì§€ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì••ì¶•í•˜ëŠ” ë°©ì‹.

- **ë¶„í• **: ì´ë¯¸ì§€ë¥¼ 4ê°œì˜ ì˜ì—­ìœ¼ë¡œ ë¶„í• 
- **ì •ë³µ**: ê° ì˜ì—­ì´ ë™ì¼í•œ ìƒ‰ì¸ì§€ í™•ì¸í•˜ê³  ì¬ê·€ì ìœ¼ë¡œ ì••ì¶•
- **ê²°í•©**: ì¿¼ë“œíŠ¸ë¦¬ êµ¬ì¡°ë¡œ ì „ì²´ ì¸ì½”ë”©

> â± ì‹œê°„ ë³µì¡ë„: **O(nÂ²)** (ì´ë¯¸ì§€ í¬ê¸°ì— ë”°ë¼)

---

### 5. ğŸ“¡ ì¿¼ë“œíŠ¸ë¦¬ ë””ì½”ë” (Quadtree Decoder)

ì¿¼ë“œíŠ¸ë¦¬ë¡œ ì••ì¶•ëœ ì´ë¯¸ì§€ë¥¼ ë³µì›í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.

- **ë¶„í• **: íŠ¸ë¦¬ êµ¬ì¡°ì— ë”°ë¼ ì´ë¯¸ì§€ ì˜ì—­ ë¶„í• 
- **ì •ë³µ**: ê° ì˜ì—­ì„ ì¬ê·€ì ìœ¼ë¡œ ë³µì›
- **ê²°í•©**: ë³µì›ëœ í•˜ìœ„ ì˜ì—­ì„ ê²°í•©í•˜ì—¬ ì „ì²´ ì´ë¯¸ì§€ êµ¬ì„±

> â± ì‹œê°„ ë³µì¡ë„: **O(nÂ²)**

---

## âœ… ìš”ì•½

| ì•Œê³ ë¦¬ì¦˜                  | í•µì‹¬ ì „ëµ                    | ì‹œê°„ ë³µì¡ë„         |
|---------------------------|-------------------------------|---------------------|
| ìŠ¤íŠ¸ë¼ì„¼ í–‰ë ¬ ê³±ì…ˆ        | 7ê°œì˜ í•˜ìœ„ í–‰ë ¬ ê³±ì…ˆ ìˆ˜í–‰     | O(n^2.81)           |
| ì¹´ë¼ì¸ ë°” ì •ìˆ˜ ê³±ì…ˆ        | í° ìˆ˜ë¥¼ 3ê°œ ê³±ì…ˆìœ¼ë¡œ ì²˜ë¦¬     | O(n^1.585)          |
| í”¼ë³´ë‚˜ì¹˜ ìˆ˜ ê³„ì‚°          | ê³µì‹ ê¸°ë°˜ ì¬ê·€ ê³„ì‚°           | O(log n)            |
| ì¿¼ë“œíŠ¸ë¦¬ ì¸ì½”ë”           | ë™ì¼ ì˜ì—­ ì••ì¶•                | O(nÂ²)               |
| ì¿¼ë“œíŠ¸ë¦¬ ë””ì½”ë”           | íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ë³µì›              | O(nÂ²)               |

Divide and ConquerëŠ” ë³µì¡í•œ ë¬¸ì œë¥¼ ì¬ê·€ì ìœ¼ë¡œ í•´ê²°í•˜ëŠ” ê°•ë ¥í•œ ì „ëµì´ë©°, ë‹¤ì–‘í•œ ë¶„ì•¼ì—ì„œ íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ì— ì‚¬ìš©ë©ë‹ˆë‹¤.

# âš™ï¸ Divide and Conquer êµ¬ì¡° ë¶„ì„

ê° ì˜ˆì‹œì—ì„œ Divide and Conquer ê¸°ë²•ì´ ì–´ë–»ê²Œ ì ìš©ë˜ëŠ”ì§€ êµ¬ì¡°ì ìœ¼ë¡œ ì •ë¦¬í•œ ë¬¸ì„œì…ë‹ˆë‹¤.

---

## 1. ğŸ”¢ ìŠ¤íŠ¸ë¼ì„¼ í–‰ë ¬ ê³±ì…ˆ (Strassen's Matrix Multiplication)

```
function Strassen(A, B):
    if size is small:
        return A * B
    else:
        Divide A and B into 4 submatrices
        Compute 7 matrix products recursively:
            M1 = (A11 + A22) * (B11 + B22)
            M2 = (A21 + A22) * B11
            M3 = A11 * (B12 - B22)
            ...
        Combine the 7 products to get result matrix C
        return C
```

---

## 2. ğŸ§® ì¹´ë¼ì¸ ë°” ì •ìˆ˜ ê³±ì…ˆ (Karatsuba's Integer Multiplication)

```
function Karatsuba(x, y):
    if x or y is small:
        return x * y
    else:
        Split x into a and b, y into c and d
        Compute:
            ac = Karatsuba(a, c)
            bd = Karatsuba(b, d)
            ad_plus_bc = Karatsuba(a + b, c + d) - ac - bd
        Combine:
            return ac * 10^(2m) + ad_plus_bc * 10^m + bd
```

---

## 3. ğŸŒ€ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ ê³„ì‚° (Fibonacci by Divide and Conquer)

```
function Fib(n):
    if n == 0:
        return (0, 1)
    else:
        (a, b) = Fib(n // 2)
        c = a * (2 * b - a)
        d = a^2 + b^2
        if n % 2 == 0:
            return (c, d)
        else:
            return (d, c + d)
```

---

## 4. ğŸ–¼ï¸ ì¿¼ë“œíŠ¸ë¦¬ ì¸ì½”ë” (Quadtree Encoder)

```
function Encode(image):
    if region is homogeneous:
        return single value
    else:
        Divide image into 4 quadrants
        Encode each quadrant recursively
        return Node(top-left, top-right, bottom-left, bottom-right)
```

---

## 5. ğŸ“¡ ì¿¼ë“œíŠ¸ë¦¬ ë””ì½”ë” (Quadtree Decoder)

```
function Decode(node):
    if node is a value:
        return filled region with that value
    else:
        Decode top-left, top-right, bottom-left, bottom-right
        Combine the 4 regions into full image
        return image
```

---

ì´ êµ¬ì¡°ë“¤ì€ ê° ë¬¸ì œì— ë§ëŠ” **Divide â†’ Conquer â†’ Combine** íë¦„ì„ ë”°ë¥´ë©°, ì¬ê·€ì ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
